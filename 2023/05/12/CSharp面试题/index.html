<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="高级试题 1.C#中堆和栈的区别？栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾">
<meta property="og:type" content="article">
<meta property="og:title" content="CSharp面试题">
<meta property="og:url" content="http://example.com/2023/05/12/CSharp%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="小子有出息">
<meta property="og:description" content="高级试题 1.C#中堆和栈的区别？栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-12T03:43:52.000Z">
<meta property="article:modified_time" content="2023-05-12T04:02:30.779Z">
<meta property="article:author" content="小子有出息">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/05/12/CSharp%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CSharp面试题 | 小子有出息</title><meta name="robots" content="noindex">
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="小子有出息" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小子有出息</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-book fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/12/CSharp%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="小子有出息">
      <meta itemprop="description" content="人生昧旅，砥砺而行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小子有出息">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSharp面试题
        </h1>

        <div class="post-meta">

	    
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-12 11:43:52 / 修改时间：12:02:30" itemprop="dateCreated datePublished" datetime="2023-05-12T11:43:52+08:00">2023-05-12</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>高级试题</strong></p>
<p>1.<strong>C#中堆和栈的区别？</strong><br>栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；<br>堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC) 来回收。<br>栈内存无需我们管理，也不受 GC 管理。当栈顶元素使用完毕，立马释放。而堆则需要 GC 清理。<br>使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身</p>
<p>2.<strong>C#中的委托是什么？事件是不是一种委托？</strong><br>委托的本质是一个类，委托是将一种方法作为参数代入到另一种方法。 事件是委托的实例，事件是一种 特殊的委托。 &#x2F;&#x2F; 比如： onclick 事件中的参数就是一种方法。</p>
<p>3**.C#静态构造函数特点是什么？**<br>是最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数<br>执行顺序：静态变量 &gt; 静态构造函数 &gt; 实例变量 &gt; 实例构造函数</p>
<p>4.CTS、CLS、CLR分别作何解释<br>CTS ：通用语言系统。 CLS ：通用语言规范。 CLR ：公共语言运行库。<br>CTS ： Common Type System 通用类型系统。 Int32 、 Int16 → int 、 String → string 、 Boolean → bool 。<br>每种语言都定义了自己的类型， .NET 通过 CTS 提供了公共的类型，然后翻译生成对应的 .NET 类型。<br>CLS ： Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.NET 通过 CLS 提供了公共的语法，然后不同语言翻译生成对应的 .NET 语法。<br>CLR ： Common Language Runtime 公共语言运行时，就是 GC 、 JIT 等这些。有不同的 CLR ，比如服务器<br>CLR 、 Linux CLR （ Mono ）、 Silverlight CLR(CoreCLR) 。相当于一个发动机，负责执行 IL 。</p>
<p>5.<strong>C#中什么是值类型与引用类型？</strong><br>值类型： struct 、 enum 、 int 、 float 、 char 、 bool 、 decimal<br>引用类型： class 、 delegate 、 interface 、 array 、 object 、 string</p>
<p>6.<strong>请详述在C#中类(class)与结构(struct)的异同？</strong><br>class 可以被实例化 , 属于引用类型 ,<br>class 可以实现接口和单继承其他类 , 还可以作为基类型 , 是分配在内存的堆上的<br>struct 属于值类型 , 不能作为基类型 , 但是可以实现接口 , 是分配在内存的栈上的 .</p>
<p>7.new关键字的作用<br>运算符：创建对象实例<br>修饰符：在派生类定义一个重名的方法，隐藏掉基类方法<br>约束：泛型约束定义，约束可使用的泛型类型<br>8.int?和int有什么区别<br>int ？为可空类型，默认值可以是 null<br>int 默认值是 0<br>int? 是通过 int 装箱为引用类型实现<br>9.C#中值传递与引用传递的区别是什么？<br>值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，<br>此后，被调用方法中形参值得任何改变都不会影响到相应的实参；<br>引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，<br>因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值得任何改变都将影响到作<br>为引用传递的实参。<br>简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一<br>个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。<br>10.C#中参数传递 ref 与 out 的区别？<br>（ 1 ） ref 指定的参数在函数调用时必须先初始化，而 out 不用<br>（ 2 ） out 指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而 ref 不用<br>总结： ref 可以把值传到方法里，也可以把值传到方法外； out 只可以把值传到方法外<br>注意： string 作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上ref 或 out 关键字。<br>11.C#中什么是装箱和拆箱？<br>装箱：把值类型转换成引用类型<br>拆箱：把引用类型转换成值类型<br>装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。<br>（ 1 ）第一步：新分配托管堆内存 ( 大小为值类型实例大小加上一个方法表指针。<br>（ 2 ）第二步：将值类型的实例字段拷贝到新分配的内存中。<br>（ 3 ）第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。<br>拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。<br>在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。<br>int i&#x3D;0;<br>System.Object obj&#x3D;i; &#x2F;&#x2F; 这个过程就是装箱！就是将 i 装箱！<br>int j&#x3D;(int)obj;&#x2F;&#x2F; 这个过程 obj 拆箱！<br>12.C#实现多态的过程中 overload 重载 与override 重写的区别？<br>override 重写与 overload 重载的区别。<br>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要<br>override 是进行基类中函数的重写。实现多态。<br>重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。<br>重写：是对基类中的虚方法进行重写。重写是面向对象的概念。 13.C# 中 static 关键字的作用？<br>对类有意义的字段和方法使用 static 关键字修饰，称为静态成员，通过类名加访问操作符 “.” 进行访问 ; 对<br>类的实例有意义的字段和方法不加 static 关键字，称为非静态成员或实例成员。<br>注 : 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否<br>为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。<br>14.C# 成员变量和成员函数前加static的作用？<br>它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。<br>分别用来反映类的状态。<br>比如类成员变量可以用来统计类实例的数量，类成员函数<br>负责这种统计的动作。不用 new<br>15.C#中索引器的实现过程，是否只能根据数字进行索引，请描述一 下<br>C# 通过提供索引器，可以象处理数组一样处理对象。特别是属性，每一个元素都以一个 get 或 set 方法暴<br>露。索引器不单能索引数字（数组下标），还能索引一些 HASHMAP 的字符串，所以，通常来说， C# 中<br>类的索引器通常只有一个，就是 THIS ，但也可以有无数个，只要你的参数列表不同就可以了索引器和返<br>回值无关 , 索引器最大的好处是使代码看上去更自然，更符合实际的思考模式。<br>微软官方一个示例：<br>索引器允许类或结构的实例按照与数组相同的方式进行索引。 索引器类似于属性，不同之处在于它们的<br>访问器采用参数。 在下面的示例中，定义了一个泛型类（ class SampleCollection ），并为其提供了简<br>单的 get 和 set 访问器 方法（作为分配和检索值的方法）。 Program 类为存储字符串创建了此类的一个<br>实例。<br>16.C#中 abstract class和interface有什么区别?<br>abstract class abstract 声明抽象类抽象方法，一个类中有抽象方法，那么这个类就是抽象类了。所谓的 抽象方法，就是不含主体（不提供实现方法），必须由继承者重写。因此，抽象类不可实例化，只能通 过继承被子类重写。<br>interface 声明接口，只提供一些方法规约，在 C#8 之前的版本中不提供任何实现，在 C#9 版本也可以支 持接口的实现；不能用public 、 abstract 等修饰，无字段、常量，无构造函数<br>两者区别：<br>1.interface 中不能有字段，而 abstract class 可以有 ; 2.interface 中不能有 public 等修饰符，而 abstract<br>class 可以有。 3.interface 可以实现多继承 。<br>17.C#中用sealed修饰的类有什么特点？<br>密封，不能继承。<br>18.字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别<br>string.Empty 相当于 “”,Empty 是一个静态只读的字段。 string str&#x3D;”” , 初始化对象，并分配一个空字符串 的内存空间 string str&#x3D;null, 初始化对象，不会分配内存空间<br>19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D; 256; 这些变量有些错误是错在哪里?<br>本题考查的是数据类型能承载数据的大小。<br>1byte &#x3D;8bit ， 1 个汉字 &#x3D;2 个 byte ， 1 个英文 &#x3D;1 个 byte&#x3D;8bit<br>所以 bc 是对的， deg 是错的。 ‘a’ 是 char 类型， a 错误<br>java byte 取值范围是 -128<del>127, 而 C# 里一个 byte 是 0</del>255<br>20.string和StringBuilder的区别,两者性能的比较<br>都是引用类型，分配再堆上 StringBuilder默认容量是 16 ，可以允许扩充它所封装的字符串中字符的数量 . 每个 StringBuffer 对象都有 一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会 自动增加容量。<br>对于简单的字符串连接操作，在性能上 stringbuilder 不一定总是优于 strin 因为 stringbulider 对象的创建 也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder 会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder 的使用。从最后分析可以看出如果是相对 较少的字符串拼接根本看不出太大差别。<br>Stringbulider 的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分<br>21.什么是扩展方法？<br>一句话解释，扩展方法使你能够向现有类型 “ 添加 ” 方法，无需修改类型<br>条件：按扩展方法必须满足的条件， 1. 必须要静态类中的静态方法 2. 第一个参数的类型是要扩展的类型，并且需要添加this 关键字以标识其为扩展方法<br>建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现<br>使用：不能通过类名调用，直接使用类型来调用</p>
<ol start="22">
<li>特性是什么？如何使用？<br>特性与属性是完全不相同的两个概念，只是在名称上比较相近。 Attribute 特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll 内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息<br>23.什么叫应用程序域(AppDomain)<br>一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。<br>应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行 为可以预知。<br>在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。<br>24.byte a &#x3D;255;a+&#x3D;5;a的值是多少？<br>byte 的取值范围是 -2 的 8 次方至 2 的 8 次方 -1 ， -256 至 258 ， a+&#x3D;1 时， a 的值时 0 ， a+&#x3D;5 时， a 的值是 0 ，所 以a+&#x3D;5 时，值是 4<br>25.const和readonly有什么区别？<br>都可以标识一个常量。主要有以下区别：<br>1 、初始化位置不同。 const 必须在声明的同时赋值； readonly 即可以在声明处赋值 ;<br>2 、修饰对象不同。 const 即可以修饰类的字段，也可以修饰局部变量； readonly 只能修饰类的字段<br>3 、 const 是编译时常量，在编译时确定该值； readonly 是运行时常量，在运行时确定该值。<br>4 、 const 默认是静态的；而 readonly 如果设置成静态需要显示声明<br>5 、修饰引用类型时不同， const 只能修饰 string 或值为 null 的其他引用类型； readonly 可以是任何类型。<br>26.分析下面代码，a、b的值是多少？<br>分析：一个字母、数字占一个 byte ，一个中文占占两个 byte ，所以 a&#x3D;8,b&#x3D;5<br>27.Strings &#x3D; new String(“xyz”);创建了几个String Object?<br>两个对象，一个是 “xyz”, 一个是指向 “xyz” 的引用对象 s 。<br>28.c#可否对内存直接操作</li>
</ol>
<p>C# 在 unsafe 模式下可以使用指针对内存进行操作 , 但在托管模式下不可以使用指针， C#NET 默认不运行带指针的，需要设置下，选择项目右键-&gt; 属性 -&gt; 选择生成 -&gt;“ 允许不安全代码 ” 打勾 -&gt; 保存<br>29.什么是强类型，什么是弱类型？哪种更好些？为什么?<br>强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类 型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译 型编程语言，如c++,java,c#,pascal等 , 弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活， 多用于解释型编程语言，如javascript 等<br>30.Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?<br>Math.Round(11.5)&#x3D;12<br>Math.Round(-11.5)&#x3D;-12<br>31.&amp;和&amp;&amp;的区别<br>相同点 &amp;和 &amp;&amp; 都可作逻辑与的运算符，表示逻辑与（ and ），当运算符两边的表达式的结果都为 true 时，其结 果才为true ，否则，只要有一方为 false ，则结果为 false 。（ ps ：当要用到逻辑与的时候 &amp; 是毫无意义， &amp;本身就不是干这个的）<br>string strTmp &#x3D; “a1某某某 “;<br>int a &#x3D; System.Text.Encoding.Default.GetBytes(strTmp).Length;<br>int b &#x3D; strTmp.Length; 不同点<br>if(loginUser!&#x3D;null&amp;&amp;string.IsnullOrEmpty(loginUser.UserName))<br>&amp;&amp; 具有短路的功能，即如果第一个表达式为 false ，则不再计算第二个表达式，对于上面的表达式，当loginUser为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp; ，则 会抛出NullPointerException 异常。（ ps ：所以说当要用到逻辑与的时候 &amp; 是毫无意义的） &amp; 是用作位运算的。 总结 &amp;是位运算，返回结果是 int 类型 &amp;&amp; 是逻辑运算，返回结果是 bool 类型<br>32.i++和++i有什么区别？<br>1.i++ 是先赋值，然后再自增； ++i 是先自增，后赋值。<br>2.i&#x3D;0 ， i++&#x3D;0 ， ++i&#x3D;1 ； Console.WriteLine(++i&#x3D;&#x3D;i++); 结果位 true<br>33.as和is的区别<br>as 在转换的同时判断兼容性，如果无法进行转换，返回位 null （没有产生新的对象）， as 转换是否成功<br>判断的依据是是否位 null is 只是做类型兼容性判断，并不执行真正的类型转换，返回 true 或 false ，对象<br>为 null 也会返回 false 。<br>as 比 is 效率更高， as 只需要做一次类型兼容检查<br>34.谈谈final、finally的区别。<br>final ：不能作为父类被继承。一个类不能声明是 final ，又声明为 abstract 。<br>finally ：用于 try{}catch{}finally{} 结构，用于异常处理时执行任何清除操作。<br>35.简述C#成员修饰符<br>abstract: 指示该方法或属性没有实现。<br>const: 指定域或局部变量的值不能被改动。<br>event: 声明一个事件。<br>extern: 指示方法在外部实现。<br>override: 对由基类继承成员的新实现。<br>readonly: 指示一个域只能在声明时以及相同类的内部被赋值。<br>static: 指示一个成员属于类型本身 , 而不是属于特定的对象。<br>virtual: 指示一个方法或存取器的实现可以在继承类中被覆盖。<br>36.什么是匿名类，有什么好处？<br>不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。<br>37.说说什么是逐字字符串<br>38.列举你知道的数字格式化转换<br>39.说说字符串拼接、字符串内插法<br>40.什么是虚函数？什么是抽象函数？<br>虚函数：没有实现的，可以由子类继承并重写的函数。<br>抽象函数：规定其非虚子类必须实现的函数，必须被重写。<br>41.什么是WebService?<br>答： Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service 能与其他兼容的组件进行互操作。<br>42.ADO.NET常用对象有哪些？<br>Connection ： 主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据 库中取得数据的。Close 和 Dispose 的区别， Close 以后还可以 Open ， Dispose 以后则不能再用。<br>Command ： 主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数<br>据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在 Connection 对象上，也就是<br>Command ： 对象是通过在 Connection 对象连接到数据源。<br>DataAdapter ： 主要是在数据源以及 DataSet 之间执行数据传输的工作，它可以透过 Command 对象下 达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在 Command 对象上，并提供了许多 配合DataSet 使用的功能。<br>DataSet ： 这个对象可以视为一个暂存区（ Cache ），可以把从数据库中所查询到的数据保留起来甚至可以将整个数据库显示出来，DataSet 是放在内存中的。 DataSet 的能力不只是可以储存多个 Table 而已，还可以透过DataAdapter 对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。 DataSet 对象可以说是 ADO.NET 中重量级的对象，这个对象架构在 DataAdapter 对象上，本身不具备和 数据源沟通的能力；也就是说我们是将DataAdapter 对象当做 DataSet 对象以及数据源间传输数据的桥 梁。DataSet 包含若干 DataTable 、 DataTableTable 包含若干 DataRow 。<br>DataReader ： 当我们只需要循序的读取数据而不需要其它操作时，可以使用 DataReader 对象。<br>DataReader 对象只是一次一次向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而 不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一条，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全 部传回，故可以降低网络的负载。<br>43.在ASP.NET中所有的自定义用户控件都必须继承自？<br>Control 类<br>44.在.NET托管代码总我们不必担心内存泄漏，这是因为有了？<br>GC 垃圾收集器。<br>45.什么是MVC模式<br>MVC(Model View Controller) 模型－视图－控制器<br>aspx 就是 View ，视图； Model ： DataSet 、 Reader 、对象； Controller ： cs 代码。<br>MVC 是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事<br>情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理<br>了。它强制性的使应用程序的输入、处理和输出分开。 MVC 最大的好处是将逻辑和页面分离。 46. 能用 foreach 遍历访问的对象的要求<br>需要实现 IEnumerable 接口或声明 GetEnumerator 方法的类型。<br>47.什么是反射?<br>程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能<br>够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类<br>型的字段属性。它是在运行时创建和使用类型实例。<br>48.ORM中的延迟加载与直接加载有什么异同？<br>延迟加载（ Lazy Loading ）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。<br>49.简述Func与Action的区别？<br>Func 是有返回值的委托， Action 是没有返回值的委托。<br>50.23种设计模式分别叫什么名称，如何分类？<br>分三类：<br>创建型，行为型，结构型；<br>创建型包含：</p>
<ol>
<li>单例模式</li>
<li>工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
<li>工厂方法模式<br>行为型包含：</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式<br>结构型设计模式包含：</li>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ol>
<!-- flag of hidden posts -->
    </div>

    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>小子有出息
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/05/12/CSharp%E9%9D%A2%E8%AF%95%E9%A2%98/" title="CSharp面试题">http://example.com/2023/05/12/CSharp面试题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODQxMC8zNDg3Mw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小子有出息"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">小子有出息</p>
  <div class="site-description" itemprop="description">人生昧旅，砥砺而行</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-04 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小子有出息</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">16k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共13.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
